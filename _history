{"entries":[{"timestamp":1770676266370,"editorVersion":"2.0.63","changes":[{"type":"edited","filename":"pxt.json","patch":[{"start1":197,"length1":115,"diffs":[[1,"    \"preferredEditor\": \"blocksprj\",\n    \"languageRestriction\": \"no-blocks\",\n    \"additionalFilePaths\": []\n"]]}]},{"type":"added","filename":"test.ts","value":"// tests go here; this will not be compiled when this package is used as an extension.\n"},{"type":"added","filename":"main.blocks","value":"<xml xmlns=\"http://www.w3.org/1999/xhtml\">\n  <variables></variables>\n  <block type=\"pxt-on-start\" x=\"0\" y=\"0\"></block>\n</xml>"}]}],"snapshots":[{"timestamp":1770676266369,"editorVersion":"2.0.63","text":{"main.ts":"interface ParticleDemonstration {\n    start(): particles.ParticleSource[];\n}\n\n// show controls\nlet ctlMessage = image.create(scene.screenWidth(), 10);\nctlMessage.printCenter(\"Effects: 'A' (+), 'B' (-)\", 0, 0);\nlet msgSprite = sprites.create(ctlMessage);\nlet msgInterval = 0;\n\nconst myDemonstrations: ParticleDemonstration[] = [];\nlet count = 1;\n\ncontroller.A.onEvent(ControllerButtonEvent.Pressed, function () {\n    count = Math.min(count + 1, 6);\n});\n\ncontroller.B.onEvent(ControllerButtonEvent.Pressed, function () {\n    count = Math.max(count - 1, 1);\n});\n\nnamespace demonstrations {\n    export class Fire implements ParticleDemonstration {\n        start() {\n            const sources: particles.ParticleSource[] = [];\n            const factory = new particles.FireFactory(8);\n            const src = new particles.FireSource(makeSimpleAnchor(), 100, factory);\n            src.setAcceleration(0, -40);\n\n            sources.push(src);\n            return sources;\n        }\n    }\n\n    export class Spinner implements ParticleDemonstration {\n        start() {\n            class RingFactory extends particles.RadialFactory {\n                createParticle(anchor: particles.ParticleAnchor) {\n                    const p = super.createParticle(anchor);\n                    p.lifespan = this.galois.randomRange(200, 350);\n                    return p;\n                }\n            }\n\n            const sources: particles.ParticleSource[] = [];\n            const colors = [0x9, 0xA, 0xB, 0xC];\n            const factory = new RingFactory(20, 30, 10, colors);\n            const src = new particles.ParticleSource(makeSimpleAnchor(), 400, factory);\n\n            sources.push(src);\n            return sources;\n        }\n    }\n\n    export class BubbleConfetti implements ParticleDemonstration {\n        start() {\n            const sources: particles.ParticleSource[] = [];\n            const min = 1000;\n            const anchor = makeSimpleAnchor();\n            anchor.width = screen.width;\n\n            const bubbleFactory = new particles.BubbleFactory(anchor, min, min * 2.5);\n            sources.push(new particles.BubbleSource(anchor, 30, bubbleFactory.stateCount - 1, bubbleFactory));\n\n            const confettiFactory = new particles.ConfettiFactory(anchor.width, 16);\n            confettiFactory.setSpeed(50);\n\n            sources.push(new particles.ParticleSource(anchor, 50, confettiFactory));\n            return sources;\n        }\n    }\n\n    export class RadialGroup implements ParticleDemonstration {\n        start() {\n            const sources: particles.ParticleSource[] = [];\n            const anchor = makeSimpleAnchor();\n\n            const radius = Math.percentChance(50) ? 0 : 20;\n            const increaseRate = Math.percentChance(50);\n\n            control.runInParallel(() => {\n                for (let i = 0; i < 3; ++i) {\n                    const colors = Math.percentChance(10) ?\n                        [0xC, 0xD, 0xE]\n                        :\n                        Math.percentChance(50) ?\n                            [0x6, 0x7, 0x8, 0x9, 0xA]\n                            :\n                            undefined;\n                    let factory: particles.ParticleFactory = new particles.RadialFactory(radius, 90, 5, colors);\n                    const src = new particles.ParticleSource(anchor, increaseRate ? 50 + (i * 50) : 100, factory);\n                    sources.push(src);\n                    pause(350);\n                }\n            });\n\n            return sources;\n        }\n    }\n\n    export class Stars implements ParticleDemonstration {\n        start() {\n            class StarFactory extends particles.ParticleFactory {\n                protected galois: Math.FastRandom;\n                protected possibleColors: number[];\n                images: Image[];\n\n                constructor(possibleColors?: number[]) {\n                    super();\n                    this.galois = new Math.FastRandom();\n                    this.images = [\n                        img`\n                            1\n                        `, img`\n                            1 . 1\n                            . 1 .\n                            1 . 1\n                        `, img`\n                            . 1 .\n                            1 1 1\n                            . 1 .\n                        `\n                    ];\n\n                    if (possibleColors && possibleColors.length)\n                        this.possibleColors = possibleColors;\n                    else\n                        this.possibleColors = [1];\n                }\n\n                createParticle(anchor: particles.ParticleAnchor) {\n                    const p = super.createParticle(anchor);\n\n                    p._x = Fx8(this.galois.randomRange(0, screen.width));\n                    p._y = Fx8(0);\n                    p.vy = Fx8(this.galois.randomRange(40, 60));\n\n                    // set lifespan based off velocity and screen height (plus a little to make sure it doesn't disappear early)\n                    p.lifespan = Fx.toInt(Fx.mul(Fx.div(Fx8(screen.height + 20), p.vy), Fx8(1000)));\n\n                    const length = this.possibleColors.length - 1;\n                    p.color = this.possibleColors[this.possibleColors.length - 1];\n                    for (let i = 0; i < length; ++i) {\n                        if (this.galois.percentChance(50)) {\n                            p.color = this.possibleColors[i];\n                            break;\n                        }\n                    }\n\n                    // images besides the first one are only used on occasion\n                    p.data = this.galois.percentChance(15) ? this.galois.randomRange(1, this.images.length - 1) : 0;\n\n                    return p;\n                }\n\n                drawParticle(p: particles.Particle, x: Fx8, y: Fx8) {\n                    // on occasion, twinkle from white to yellow\n                    const twinkleFlag = 0x8000;\n                    const rest = 0x7FFF;\n                    if (twinkleFlag && p.data) {\n                        if (this.galois.percentChance(10)) {\n                            p.color = 1;\n                            p.data &= rest;\n                        }\n                    } else if (p.color === 1 && this.galois.percentChance(1)) {\n                        p.color = 5;\n                        p.data |= twinkleFlag;\n                    }\n\n                    const selected = this.images[rest & p.data].clone();\n                    selected.replace(0x1, p.color);\n                    screen.drawImage(selected, Fx.toInt(x), Fx.toInt(y));\n                }\n            }\n\n            const sources: particles.ParticleSource[] = [];\n            const colors = [1];\n            for (let i = 0; i < 4; i++)\n                colors.push(randint(2, 0xE));\n\n            const factory = new StarFactory(colors);\n            const src = new particles.ParticleSource(makeSimpleAnchor(), 25, factory)\n            sources.push(src);\n            return sources;\n        }\n    }\n}\n\nfunction makeSimpleAnchor(): particles.ParticleAnchor {\n    return {\n        x: screen.width >> 1,\n        y: screen.height >> 1\n    };\n}\n\n// Radial group as a lot of different possible configurations, so make it twice as likely as others\nfor (let i = 0; i < 2; i++) {\n    myDemonstrations.push(new demonstrations.RadialGroup());\n}\nmyDemonstrations.push(new demonstrations.Stars());\nmyDemonstrations.push(new demonstrations.BubbleConfetti());\nmyDemonstrations.push(new demonstrations.Spinner());\nmyDemonstrations.push(new demonstrations.Fire());\n\nforever(() => {\n    particles.disableAll()\n\n    for (let i = 0; i < count; ++i) {\n        Math.pickRandom(myDemonstrations)\n            .start();\n    }\n\n    msgSprite.top = scene.screenHeight();\n    msgSprite.top += msgInterval % 5 == 0 ? -10 : 0;\n    msgInterval += 1;\n    pause(3000);\n});","README.md":" ","assets.json":"","pxt.json":"{\n    \"name\": \"particle effects demo\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"device\": \"*\"\n    },\n    \"files\": [\n        \"main.ts\",\n        \"README.md\",\n        \"assets.json\"\n    ],\n    \"preferredEditor\": \"blocksprj\",\n    \"languageRestriction\": \"no-blocks\",\n    \"additionalFilePaths\": []\n}\n"}}],"shares":[],"lastSaveTime":1770676325542}